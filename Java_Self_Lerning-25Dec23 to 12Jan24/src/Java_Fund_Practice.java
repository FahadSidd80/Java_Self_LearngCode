
public class Java_Fund_Practice {

	public static void main(String[] args) {
		
//		int x = 20;  // variable name : x
		
 // Topic 1. these all are identifiers. can be used for identification purpose
		
//		int x = 10;
//		System.out.println(x); // 10
		
//		int Number = 10;
//		int number = 90;
//		int NUMBER = 40;
//		System.out.println(Number+" "+number+" "+NUMBER);//10 90 40
		

		// ex : int Number = 10;
		// int NUMBER = 10;
		// int number = 10;
		// all above line has different meaning.
//		
//		int if = 10;
//		System.out.println(if);
//		
//		int String = 10;
//		System.out.println(String); // 10
		
//		int String = 344;
//		System.out.println(String);	// o/p: 344
		
//		
//		int main = 19;
//		System.out.println(main); // 19
		
		
//		int runnable =999;
//		System.out.println(runnable); //999
		
//		int Java_Fund_Practice =90;
//		System.out.println(Java_Fund_Practice);// 90
		
//		int args =90;
//		System.out.println(args);// Duplicate local variable args

//		int _$_$___$_$_ = 98;
//		System.out.println(_$_$___$_$_);// 98
		
		
		
//		int runnable = 900;
//		System.out.println(runnable); // o/p : 900
//		 int   total_number = 10;
//		 int 123_total = 40;
//		 int total_123 = 121;
		
//		int java2share = 10;
//		int total123 = 20;
////		int 123total = 50;
//		System.out.println(total123);
		
//		int _$_$_$_$_$_$_$ = 20;
//		int $_$_$_$ = 90;
//		System.out.println(_$_$_$_$_$_$_$);
//		
//		 predefined wrapper class
//		int Integer = 29;
//		int Int = 30;
//		int String = 31;
//		int Char = 32;
//		int Float = 33;
//		int Double = 34;
//		int Long = 35;
//		int Short = 36;
//		int Byte = 37;
//		int Boolean = 38;
//		int Character = 39;
//		
//		
//		System.out.println(Integer);    //29   int
//		System.out.println(Int); 		//30
//		System.out.println(String);		//31   Non-Primitive
//		System.out.println(Char);		//32
//		System.out.println(Float);		//33  float
//		System.out.println(Double);		//34  double
//		System.out.println(Long);		//35  long
//		System.out.println(Short);		//36  short
//		System.out.println(Byte);		//37  byte
//		System.out.println(Boolean);	//38  boolean
//		System.out.println(Character);  //39  char  -- there is nothing exist like character
////		
//		int Int = 10;
//		int Integer = 90;
//		int INTEGER = 20;
//		System.out.println(Integer); // 90
//		System.out.println(INTEGER);// 20
//		System.out.println(Int);// 10
		
//		All WRAPPER CLASS/ PRE-DEFINED JAVA CLASS
//		int Integer = 29;
//		int Int = 30;
//		int String = 31;
//		int Char = 32;
//		int Float = 33;
//		int Double = 34;
//		int Long = 35;
//		int Short = 36;
//		int Byte = 37;
//		int Boolean = 38;
//		int Character = 39;
//		
//		System.out.println(Integer);    29   int
//		System.out.println(Int); 		30  // Int not any reserved keyword/literals in java
//		System.out.println(String);		31   Non-Primitive
//		System.out.println(Char);		32
//		System.out.println(Float);		33  float
//		System.out.println(Double);		34  double
//		System.out.println(Long);		35  long
//		System.out.println(Short);		36  short
//		System.out.println(Byte);		37  byte
//		System.out.println(Boolean);	38  boolean
//		System.out.println(Character);	39  char  -- there is nothing exist like character
	
	

//		
//		int int = 20;
//		int char = 21;
//		int float = 22;
//		int bool = 23;  // nothing exist in java as bool = like wrpppaer class or any other reserved keyword, literals
////		int boolean = 25;
//	    int Boolean = 29;  // wrapper class
//		int byte = 24;
//		int short = 25;
//		int long = 26;
//		int double = 27;
//		int boolean = 28;
//		int char = 29;
		
//		System.out.println(int);
//     	System.out.println(char);
//		System.out.println(float);
		
//		int u =10;
//		System.out.println(u);
//	 	System.out.println(bool); // 23
	
//     	System.out.println(boolean);
//		System.out.println(Boolean);// 29
//		System.out.println(byte);
//		System.out.println(short);
//		System.out.println(long);
//		System.out.println(double);
//		System.out.println(boolean);
//		System.out.println(char);
	
//		int character = 20;
//		System.out.println(character);
		
//	Topic 2 . Reserved words
		
//	Reserved keyword for Primitive DT	Non_Premitive DT/Wrapper class -- which are object type
//		non object -8
//	Integral DT -4
//	1.	byte							Byte
//	2.	short							Short
//	3.	int								Integer
//	4.	long							Long
//	Floating point DT -2
//	5.	float 							Float
//	6.	double							Double
// Non Numeric DT -2
//  7.	char							Character
//	8.	boolean							Boolean
	 
		
//		String are literal
		
//		Reserved words are 53 in java
//		resreved keyword are 50 - related to functionality 
//		- but 48 are used and rest 2 are unused- goto, const
//		reserved literals are 3 - related to only value
//		- true, false, null
		
		/*
		 *  Its never too late to start !!
		 *  This too shall pass !!
		 */		
//		
		
//		PRIMITVE DATA TYPE : Numeric DT -> Integral datatype
//		1 . Byte  Range (-128 to 127)  1 byte = 8 bit
		
//		byte x = 128;
//		byte y = 127;
//		byte z =-128;
//		byte a = -129;
//		System.out.println(x);
//		System.out.println(y);
//		System.out.println(z);
//		System.out.println(a);
		
//		Byte byt = 129;
//		int  b = -129;
//		System.out.println(iny);
		
//		Except boolean and char datatype all are sign data type because we can represent in both +ve and -ve value
		
//		byte b = 10.5;
//		System.out.println(b); Type mismatch: cannot convert from double to byte
//		byte b = true;
//		System.out.println(b); Type mismatch: cannot convert from boolean to byte
//		byte b = "fahad";
//		System.out.println(b); Type mismatch: cannot convert from String to byte
		
		
//		byte b = 10.0;
//		System.out.println(b);
		
//		byte b = true;
//		System.out.println(b);
		
//		byte b = 'A';
//		byte x = "Akalka";
//		System.out.println(b);
		
//		Two types of stream :
//		Character stream and byte stream
		
//		 2. Short  DT - most rarely used 
//		range (-2^15 to 2^15-1) (-32768 to 32767)  2 byte = 16 bit.
		
//		short s = 32767;
//		System.out.println(s);
////		
//		Short s = 32768;
//		System.out.println(s); Type mismatch: cannot convert from int to Short
		
//		short s = -32768;
//		System.out.println(s);
//		
//		short s = -32769;
//		System.out.println(s); Type mismatch: cannot convert from int to short
		
//		short s = 10.5;  
//		System.out.println(s); Type mismatch: cannot convert from double to short
		
//		short s = = true;
//		System.out.println(s);   Type mismatch: cannot convert from boolean to short
		
		
//		short s = 'A';
//		System.out.println(s);// 65
		
		
//		3. int data type 
//		range (-2^31 to 2^31-1) (-2147483648  to 2147483647)  4 byte = 32 bits
		
//		int x = -2147483648;
//		System.out.println(x);
		
//		int x = 2147483647;
//		System.out.println(x);
	
//		Note : Every integarl number by default going to be considered  as int type. So, error in int will be different.
		
//		int x = -2147483649;
//		System.out.println(x);//The literal 2147483649 of type int is out of range 
		
		
//		int x = 2147483648;
//		System.out.println(x); // Exception in thread "main" java.lang.Error: Unresolved compilation problem: 
//								The literal 2147483648 of type int is out of range : means integer ki range se bahar hai
		
//		int x = 2147483648l;  // treated as long : special case
//		System.out.println(x); //Type mismatch: cannot convert from long to int
		
//		long x = 2147483648; // The literal 2147483648 of type int is out of range 
//		System.out.print(x);
		
//		long l = 2147483647;
//		System.out.print(l); // but treated as int not long one.
		
//		long x =  2147483648l; // now treaded as long
//		System.out.print(x);
		
//		int x = true;
//		System.out.println(x); Type mismatch: cannot convert from boolean to int
		
//		4. Long : 
//			Range (-2^63 to 2^63-1) 8 bytes = 64 bits
//		long l = 2147483647;// treated as int and under range of int also.
//		long l1 = 2147483647l; // now its long only.
//		System.out.println(l);
//		System.out.print(l1);
//		
//		long l = 12209342084092184901284091284298429849249249249292929239218989128921892189; // The literal 12209342084092184901284091284298429849249249249292929239218989128921892189 of type int is out of range 
//		System.out.println(l);// The literal of type int is out of range 
		
		
//		long l = 12209342084092184901284091284298429849249249249292929239218989128921892189l; // The literal 12209342084092184901284091284298429849249249249292929239218989128921892189 of type int is out of range 
//		System.out.println(l);// The literal  of type long is out of range 
		
//		long l2 = 1220934208409999999l;
//		System.out.println(l2);
		
//		long l = 12209342084092184901284091284298429849249249249292929239218989128921892189l; // The literal 12209342084092184901284091284298429849249249249292929239218989128921892189l of type long is out of range 
//		System.out.print(l);
		
//		long l = 1073741824l;
//		long l1 = 1152921504606846976l;
//		long l3 = 8l;
//		long mull = (l1*l3);  // -9223372036854775808
//		long mul = (l*l);
//		System.out.println(mul);// 1152921504606846976
//		
//		System.out.print(mull);// -9223372036854775808
		
//		FLOATING POINT DATA TYPES : 1. FLOAT  2. DOUBLE
		
//		1. Float 
//		 5 to 6 didgits accuracy.
//		single precision
//		size : 4 bytes = 32 bits
//		 range : (-3.4 * 10^38 to 3.4 * 10^38 ) -3.4 e^38 to 3.4e^38  -- MeE - Here, MeE denotes M multiplied by 10 to the E'th power. 
		//mEe is computer notation for m times 10 to the e power.
		
//		float fx = 12f;
//		float fn = 29/7; //  4.0
//		
//		System.out.println(fn+" "+fx); //12.0
//		float f = 1234/232;
//		System.out.println(f); // 5.0
		
		
//		2. Double 
//		 14 to 15 digits accuracy
//		 double precision
//		 size 8 bytes = 64bits
//		 range : -1.7e^308 to 1.7e^308 
		
//		double d = 29.121313;
//		
//		System.out.println(d);
		
//		double d = 1212323.2321321;
//		System.out.println(d);
		
//		double d = 1000000/33;
//		System.out.println(d);
		
//		09/09/2023-Saturday
		
//		Non Numeric data type.
//		Boolean - true/false
//		SIze : N.A (size depends upon machine only)
//		Range : N.A (true/false only allowed value)
		
//		boolean b = true;
//		boolean b1 = 0; // Type mismatch: cannot convert from int to boolean
//		System.out.println(b1); 
		
//		boolean b = true;
//		boolean b = 19;// Type mismatch: cannot convert from int to boolean
//		System.out.println(b);
		
//		 boolean b = True; // True cannot be resolved to a variable
//		 System.out.println(b);
		
//		boolean b = s; // s cannot be resolved to a variable
//		System.out.println(b);
		
//		boolean b = 'A';
//		boolean b = "Fahad String";// Type mismatch: cannot convert from String to boolean
//		System.out.println(b);// Type mismatch: cannot convert from char to boolean
				
//		boolean b = 'A'; // Type mismatch: cannot convert from char to boolean
//		System.out.println(b);
		
//		boolean b = "String"; Type mismatch: cannot convert from String to boolean
//		System.out.println(b);
//		
//		
//		int x = 0;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello");
//		}
//		else {
//			System.out.println("Hii");
//		}
		
//		int x = 0;
//		if(x) // Type mismatch: cannot convert from int to boolean
//		{
//			System.out.println("Hello");
//		}else
//		{
//			System.out.println("Hii");
//		}
//		
//		while(1)  // Type mismatch: cannot convert from int to boolean
//		{
//			System.out.print("Hello");
//			
//		}
//		while (1) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hii");
//		}
//		int x= 90;
//		if(x!=90) {
//			System.out.println("Hello");
//		}
//		else
//		{
//			System.out.println("Hii");
//		}
//		
//		2. Char 
//		Size - 2 byte = 16 bit
//		Range - (0 to 65535)	
//		int x,y;
//		x=19;
//		System.out.println(x);
		
//		char ch = null ;
//		System.out.println(ch);/// 	Type mismatch: cannot convert from null to char
//		char ch = 'ABBBB';// Invalid character constant
//		System.out.println(ch); // Type mismatch: cannot convert from null to char
//	
//		 char ch = 'X';
//		 System.out.println(ch);
		
		
		/// LITERALS :-
		
//		int x = 19;  19 is literal/constant value
		
//		Decimal literals 
//		int x = 10; // by default decimal
//		int x1 = 010;// octal value
//		System.out.println(x1);//8 but return op in decimal form
		
//		int x4 = 0x10;// hexa decimal value
//		System.out.println(x4); //return 16 in decimal form 
		
//		int hd = 0X10;
//		System.out.println(hd); // 16
//		int x1 = 010; // here 0 means octal
//		int x2 = 0x10; // here 0x means hexadecimal
//		System.out.println(x);  //10
//		System.out.println(x1); 8
//		System.out.println(x2); 16
		
//		int x = 0X10;
//		System.out.println(x); // 16  from a to f java is not case sensitive. we can use both caps and small letter to represent number in hexa deciaml vale.
		
//		int x =0x1021a;
//		System.out.println(x);/// 66074
		
//		long x= 0x109ABCDefl;// long value in hexa decimal form
//		System.out.println(x);// 4457221615 return decimal vale
		
//		int x= 0X10af;// hexa decimal literal of type int
//		System.out.println(x); // 4271 return decimal value
 
//		int x = 0x00112abcdfe; // The literal 0x00112abcdfe of type int is out of range
//		System.out.println(x);
		
//		long l = 0x00112abcdefl;
//		System.out.print(l);
		
//		int x = 0212132137;
//		System.out.println(x);
//		
//		int x1 = 0786;  // The literal 0786 of type int is out of range 
//		System.out.println(x1);
		
//		int x3 = 0786;  // The literal 0786 of type int is out of range,
////		here it statrts with 0 so its octal so we cant include 8 because 
////		octal support only 0-7 number.
//		System.out.println(x3);
		
		
//		int x = 00023327;// octal of int type
//		System.out.println(x);// 9943- decimal

			
//		int x = 001234567012;
//		System.out.println(x);// 175304202
		
		
//		int x = 017777777777;
//		System.out.println(x); // 2147483647
		
//		int y = 0177777777777;
//		System.out.print(y); // The literal 0177777777777 of type int is out of range- int ki range se bahar hai after conversion into decimal value
		
//		
//		int  x= 0XFace;// in hexa decimal form
//		System.out.println(x);// 64206 - in decimal form
//		int x = 0XBeef;
//		int x = 0xBeer; // Syntax error on token "r", delete this token
//		System.out.print(x);
		
//		int x = 10; // decimal
//		int y = 010; // octal
//		int  z = 0x10;// hexa decimal
//		System.out.println(x+".."+y+".."+z); // 10..8..16 -- but all value in decimal only
		
//		
//		int x = 10l; // long to int
//		int y = 010l;
//		int z = 0x10l;
//		System.out.println(x+".."+y+".."+z); 
//		Type mismatch: cannot convert from long to int - 
//		Type mismatch: cannot convert from long to int
//		Type mismatch: cannot convert from long to int
		
//		int x = 10;
//		int x= 10l;// 	Type mismatch: cannot convert from long to int
//		long l = 10l;// 10
//		long l1 = 1000000l;
//		long l3 = 010000000l;// 2097152 - in octal but long type 
//		System.out.println(l1);// 1000000
//		System.out.println(l3);// 2097152 -- in decimal form
//		long l = 10;
//		System.out.println(l);// 10
		
		
//		long l1 = 10;
//		long l2 = 010;
//		long l3 = 0x10;
//		System.out.println(l1+".."+l2+".."+l3); // 10..8..16
		
		
//		byte b = 127;
//		byte b = 128; // cannot convert from int to byte
//		System.out.println(b);
//		
//		byte b = 125b;// Syntax error on token "b", delete this token
//		System.out.println(b);// Syntax error on token "b", delete this token
		
		
		
		
//		short s = 32767;// decimal value with in short range
//		short s = 32768; // Type mismatch: cannot convert from int to short
//		System.out.println(s);
//		
//		byte b = 127;
		
		
//		FLOATING POINT LITERALS.
//		
//		float f = 123.567; // Type mismatch: cannot convert from double to float
//		System.out.print(f);
//		
		
//		float f = 123.867;
//		System.out.println(f);// Type mismatch: cannot convert from double to float
		
		
//		double d = 123.456;
//		System.out.print(d);// 123.456
		
//		float f = 123.456f;
//		float f1 = 123.456F;
//		System.out.println(f); // 123.456
//		System.out.println(f1);// 123.456
//		
//		double d = 123.456d;
//		double d1 = 123.456D;
//		System.out.println(d1);// 123.456
//		System.out.println(d);// 123.456
//		
//		float f = 123.456d;
//		System.out.print(f); // 	Type mismatch: cannot convert from double to float
		
		
//		double d = 123.456;
//		double d = 0123.456;// 123.456 // it is decimal literal but not ocatal literal.
//		double d = 0x123.456; // Invalid hex literal number
//		System.out.print(d);
		
		
//		double d = 0786; // It is in octal// The literal 0786 of type int is out of range 
//
//		System.out.println(d);
		
		
//		double d = 0123456.2323;
//		double d = 0786;// decimal value in octal form// 	The literal 0786 of type int is out of range
//		double d = 0786.0;// It is not in octal even ) is at start it is only decimal form literal
//		System.out.println(d);// 786.0 in double form
//		System.out.print(d);
//		double d = 0786.0;// it is in double 
//		System.out.print(d);  // 786.0
		
		
		
//		double d = 0xFace;// 64206.0
//		double d = 0786.0;// 786.0

//		System.out.println(d);
		
//		double d = 0xFace.0; // Invalid hex literal number
//		double d1 = 10;
//		double d2 = 0777;
//		System.out.println(d);
//		System.out.println(d1);
//		System.out.println(d2); // 511.0
		
		
		
//		int x = 10.0;
//		System.out.print(x); // Type mismatch: cannot convert from double to int
		
//		double d = 0786;// The literal 0786 of type int is out of range
//		double d1 = 0786.0;
//		double d2 = 0XFace;
//		double d3 = 0XFace.0;// Invalid hex literal number
//		System.out.println(d);
//		System.out.println(d1);// 786.0
//		System.out.println(d2);// 64206.0
//		System.out.println(d3);//	Invalid hex literal number
		
//		double d = 10; // we can assign integral literal to floating point variable
//		int x = 10.0;// Type mismatch: cannot convert from double to int
		// but // we can't assign floating point literal to integral variable
//		System.out.println(d);// 10.0
//		System.out.println(x);
		
		
		
//		FLoating point literal in exponential form
		
//		double d = 1.2e3;
//		System.out.println(d); // 1200.0
//		double d = 1.2e3;
//		System.out.println(d);// 1200.0 
		
//		float f = 1.2e3;
//		System.out.println(f); // Type mismatch: cannot convert from double to float  size means byte ka lafda hai.. from double 8 byte to float 4 byte.

//		float f = 1.2e3f;
//		float f = 1.2e3F;
//		System.out.print(f); // 1200.0
		
		
//		Non-Numeric  literal
//		1.Boolean -- true/false
//		2.Char
//		
//		boolean b = true;
//		System.out.println(b);
//		boolean b = 0;
//		boolean b1 = True;
//		boolean b2 = "True";
////		System.out.println(b);  // Type mismatch: cannot convert from int to boolean
////		System.out.println(b1); //  True cannot be resolved to a variable
//		System.out.println(b2); // Type mismatch: cannot convert from String to boolean
		
//		boolean b =true;
//		boolean b1 = false;
//		boolean b2 = True;// 	True cannot be resolved to a variable
//		boolean b3 = 0;// Type mismatch: cannot convert from int to boolean
//		boolean b4 = "true";// Type mismatch: cannot convert from String to boolean
//		boolean b5 = 32323;// Type mismatch: cannot convert from int to boolean
//		boolean b6 = 121.0;//Type mismatch: cannot convert from double to boolean
//		boolean b7 = 'B';// Type mismatch: cannot convert from char to boolean
//		boolean b8 = 'true';// Invalid character constant

//		boolean b9= 0786;// The literal 0786 of type int is out of range 
		//Type mismatch: cannot convert from int to boolean
//		boolean b10 = 0XFace;// Type mismatch: cannot convert from int to boolean
//		System.out.println(b10);
		
//		int x = 0;
//		if(x)  // Type mismatch: cannot convert from int to boolean
//		{
//			System.out.println("Hii..");
//		}
//		else 
//		{
//			System.out.println("Hello..");
//		}

//		int x=0;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hii..");
//		}else
//		{
//			System.out.println("Helo...");
//		}
//		
//		while(1)  // Type mismatch: cannot convert from int to boolean
//		{
//			System.out.println("Hello..");
//		}
//		
//		Lecture 5 : Literal Part 2
		
//		Char literal :
		
//		char ch = 'a';
//		System.out.println(ch);// a
		
//		char ch = a;
//		System.out.println(ch); // a cannot be resolved to a variable
		
//		char ch = "a"; // Type mismatch: cannot convert from String to char
//		char ch = 'ab';  //Invalid character constant
//		System.out.println(ch);
		
//		char ch = 0;
//		char ch = 97; // a
//		char ch = 65;// A
//		char ch = 0xFace; // ?means no value exist corresponding to this unicode value in this machine.
//		char ch = 0XFace; // ? means no value exist corresponding to this unicode value in this machine.
//		char ch = 0XFACE;  // ? means no value exist corresponding to this unicode value in this machine.
//		char ch = 0777; // ?means no value exist corresponding to this unicode value in this machine.
//		char ch = 65535; // ? means no value exist corresponding to this unicode value in this machine.
//		char ch = 65536; // Type mismatch: cannot convert from int to char
//		System.out.println(ch);
		
//		char ch = '\u0061';
//		System.out.println(ch);// a
		
//		char ch = '\u0000';
//		System.out.println(ch);
		
//		char ch = '\u0021';
//		System.out.println(ch);// !
//		
		
//		char ch = '\u0022';
//		System.out.println(ch);//O/P -- "
		
//   	char ch = 97; // a
//		char ch = 197; // Å
//		System.out.println(ch);
//		System.out.println(ch);
//		
//		char ch = 1970;
//		System.out.println(ch); // ?
		
//		char ch = 1971; // ?
//		char ch = 19710; // ?
//		System.out.println(ch);
		
//		Every escape character is a valid char literal
		
//		char ch = '\n';// new line
//		char ch = '\t';// horizontal tab
//		char ch = '\m'; // Invalid escape sequence (valid ones are  \b  \t  \n  \f  \r  \"  \'  \\ )
//		System.out.println(ch);
		
//		char ch = '\n'; // new line
//		char ch1 = '\t';// horizontal tab
//		char ch2 = '\r';  // carriage return
//		char ch3 = '\b';  //  back space
//		char ch4 = '\f';  //  form feed
//		char ch5 = '\"'; // " double quote
//		char ch6 = '\'';  // ' single quote
//		char ch7 = '\\';// \ back slash symbol
//		System.out.println(ch); // new line
//		System.out.println(ch1); // horizontal tab
//		System.out.println(ch2); // carriage return
//		System.out.println(ch3); //  back space
//		System.out.println(ch4); //  form feed
//		System.out.println(ch5); // " double quote
//		System.out.println(ch6); // ' single quote
//		System.out.println(ch7); // \ back slash symbol
		
//		System.out.println("This is a \' single quote sysmbol");
//		System.out.println("This is a \" double quote symbol  ");
//		System.out.println("this is a \\ back slash symbol ");
//		System.out.println("Single quotes \' symbol");
//		System.out.println("Single quotes \" symbol");
//		System.out.println("Single quotes \\ symbol");
		
//		System.out.println("this is file path C:\\\\ durga.classess "); // this is file path C:\\ durga.classess 
		
//		System.out.println("this is file path C:\\\\ java.classses");// this is file path C:\\ java.classses
		/*
		 *  Its never too late to start !!
		 *  This too shall pass !!
		 */		
		
//		char ch = 65535;
//		char ch1 = 65536;
//		char ch2 = 0XBeer;
//		char ch3 = 0XFace;
//		char ch4 = \uFace;
		
//		char ch5 = '\ubeef'; true hai
//		char ch6 = '\m';
//		char ch7 = '\iface';
//		System.out.println(ch); // ?
//		System.out.println(ch1);// Type mismatch: cannot convert from int to char
//		System.out.println(ch2);// Syntax error on token "r", delete this token
//		System.out.println(ch3);// ?
//		System.out.println(ch4);// ? cannot be resolved to a variable
//		System.out.println(ch5);// ?
//		System.out.println(ch6);// Invalid escape sequence (valid ones are  \b  \t  \n  \f  \r  \"  \'  \\ )
//		System.out.println(ch7);// Invalid escape sequence (valid ones are  \b  \t  \n  \f  \r  \"  \'  \\ )
		
//		STRING LITERAL
		
//		Any sequence of character within double quote is treated as string literal.
//		 String s= "durga";
//		 System.out.println(s);//durga

//		int x = 0b1111;// 15 -- 4 once is nothin but 15 in decimal from binary
//		int x = 0B1111;// 15
//		int x = 0b001;// 1
//		int x = 0b011;// 3
//		int x = 0b010;// 2
//		System.out.println(x);
		
//		int y = 0b111; // 7 // Binary - 0b - 0,1 - but works on 1.7vrsn or above.
//		int z = 010;  //8  // octal - 0 - 0-7
//		int x = 0x100;// 256  // hexa - 0x -0-9 10=a to15=f
//		int c = 10; // decimal - 0-9
//		System.out.println(y);
//		System.out.println(z);
//		System.out.println(x);
//		System.out.println(c);// 10
		
		
////		usage of underscore symbol -it can be used between only digits.
////		
//		double d = 1234.456;
//		double d2 = 1_2_3_4.4_5_6;
//		System.out.println(d); // 1234.456
//		System.out.println(d2);  // 1234.456
		
//		double d = _123.456; // _123 cannot be resolved to a variable
//		double d = 123_.349;  // Underscores have to be located within digits
//		double d = 123_._234; // Underscores have to be located within digits
//		double d = 123_.23323_; // Underscores have to be located within digits
//		System.out.println(d);
		
//		float f = 10l;  // Exceptional case  need to study further
//		System.out.println(f);// 10.0
		
//		float f = 10000l;
//		System.out.println(f);// 10000.0

		
//		
//		byte b = 10;
//		short s = 20;
//		int x = 10;
//		long l = 200l;
//		long sum = b + s+x+l;
//		System.out.println("Sum = "+ sum); // 240
		
//		short s = 10.5;
//		System.out.println(s);// Type mismatch: cannot convert from double to short
		
		
		
		
		
		
//		*************--START OF ARRAY CONCEPT BY DURGA SIR-************
//		*************--START OF ARRAY CONCEPT BY DURGA SIR-************
//		*************--START OF ARRAY CONCEPT BY DURGA SIR-************
//		*************--START OF ARRAY CONCEPT BY DURGA SIR-************
//		*************--START OF ARRAY CONCEPT BY DURGA SIR-************
//		*************--START OF ARRAY CONCEPT BY DURGA SIR-************
//		*************--START OF ARRAY CONCEPT BY DURGA SIR-************
//		array start
//		 An array is a indexed collection of fixed no of homogeneous data elements
		
//		int x =10;
//		int [] x = new int[10];
//		int x=10;
//		int [] xarr = new int[10];
//		double [] darr = new double[20];
		
//	 	Three type of array declaration
		
//		1_Dimensional array declaration.
//		2-D Array.
//		3-D Array.
		
//		1-D Array declaration.
		
//		int[]  x; // recommended because name is clearly seperate from type.
//		
//		int  []x; // here  int is array type. and X is name of array.  [] - this bracket represent array symbol/dimension.
//		int   x[];
		
//		int[] x1 ;
//		int  []x2;
//		int x3[];
//		
//		
//		int[6]  x;  //  Unresolved compilation problem: 
//		System.out.println(x);  // Syntax error on token "6", delete this token
// 		int[] x;  // at the time of declaration we can't specify the the size of the array.
//		System.out.println(x);
		
//		2-D Array declaration.
//		
//		int[][]  x;
//		int  [][]x;
//		int  x[][];
//		
//		
//		int[]   []x;
//		int[]    x[];
//		int     []x[];  all are valid.
// 		
// 		int[][] x1;
// 		int[] []x2;
// 		int[] x3[];
// 		int x4[][];
// 		int [][]x5;
// 		int []x6[];
 		
// 		all are valid for 2d array
 		
 		
		
//		conclusion/concept regarding dimension:
		
//		int[]  a,b;  // a=1,b=1
//		int[]  a[],b; // a=2, b=1
//		int[]  a[],b[]; // a=2,b=2
//		int[]  []a,b;   // []  []  this space is ignored by compiler.  a=2,b=2
//		
//		int[]  []a,b[]; // a=2,b=3
//		int[]  []a,[]b;  // a=2, but b is not valid. CE:
 		
// 		int[] a,b;
// 		int[] []a,b;
// 		int[] a,b[];
// 		int [][]a,b;
// 		int a[],b[];
// 		int a,b[][];
// 		int []a,b[];
// 		int[] []a,b;
 		
		
//		if you want to declare the dimension before the variable, then this rule will applicable only for the first variable in a declaration.
//		(of 2-D array). not for the second variable. If we will try to apply for next/onwards/remaining variable the we will get CTE.
		
//		int[]  []a,[]b,[]c; // a=2, b=error, c=error
		
//		3-D Array
//		
//		int[][][]   a;
//		int		[][][]a;
//		int		a[][][];
//		int[]	[][]a;
//		int[]	a[][];
//		int[]	[]a[];
//		int[][]	 []a;
//		int[][]	 a[];
//		int		[][]a[];
//		int 	[]a[][];  /// all are valid
 		
// 		int[][][] a;
// 		int [][][]a;
// 		int a[][][];
// 		int[] [][]a;
// 		int[] a[][];
// 		int[][] a[];
// 		int[][] []a;
// 		int[] [][]a;
// 		int [][]a[];
// 		int []a[][];
 		
//		
		
//		Conclusion: AT the time of decalration we cant specify the size of array.
//		To represent dimension before the variable this rule is applicable only for the first variable not for second/remainig variable and so on.
		
//		Array Creation
		
//		every array in java is object only, hence we can create array by using new keyword/operator only.
		
//		int[]  a = new  int[3];  ==> 1-D Array
		
// 		int[] a=new int[3];// Declarion and creation is only done in this line
 		
// 		int[] x=new int[3];
// 		System.out.println(x.getClass().getName());// [I - class name of 1 dimensional array
		
 		
//		int = data type
//		[] = dimension & array symbol
//		a = reference variable/ name of array
//		new = reserved keyword use for creating object
//		[3] = 3 => size of array
		
//		usually we can create object only for classess, so that every array type corresponding classes will be there.
//		every array type correspond classess are there but these classesa are only available at language level not for programmer level.
		
//		To see the class:
//			sops(a.getClass().getName());
		
//		int[] a = new int[9];
//		System.out.println(a.getClass().getName());  // [I
//		
//		byte[] a = new byte[9];
//		System.out.println(a.getClass().getName()); // [B
//		System.out.println(a); // [B@2c7b84de
//////		
//		short[] s = new short[9];
////	System.out.println(s.getClass().getName()); // [S
//		System.out.println(s);  // [S@2c7b84de

////		
//		long[] l = new long[7];
////		System.out.println(l.getClass().getName()); // [J
//		System.out.println(l); // [J@2c7b84de
////		
//		float[] f = new float[9];
////		System.out.println(f.getClass().getName()); // [F
//		System.out.println(f);  // [F@3fee733d
////		
//		double[] d= new double[9];
////		System.out.println(d.getClass().getName()); // [D
//		System.out.println(d); // [D@5acf9800
		
//		
//		boolean[] b = new boolean[9];
//		System.out.println(b); // [Z@2c7b84de
//		System.out.println(b.getClass().getName()); // [Z
		
		
//		char[] c = new char[9];
//		System.out.println(c);
//		System.out.println(c.getClass().getName()); // [C
		
		
//		2-D Array
//		int[][]  a = new int[9][7];
//		System.out.println(a.getClass().getName()); // [[I
		
//		byte[][] b = new byte[4][9];
//		System.out.println(b.getClass().getName()); // [[B
//		
//		short[][] s = new short[8][2];
//		System.out.println(s.getClass().getName()); // [[S
//		
//		long[][] l = new long[9][3];
//		System.out.println(l.getClass().getName()); // [[J
		
//		
//		float[][] f = new float[9][9];
//		System.out.println(f.getClass().getName()); // [[F
//		
//		double[][] d = new double[9][8];
//		System.out.println(d.getClass().getName()); // [[D
//		
//		boolean[][] b = new boolean[1][3];
//		System.out.println(b.getClass().getName()); // [[Z
		
//		char[][]  c= new char[2][3];
//		System.out.println(c.getClass().getName()); // [[C
//		
//		int[][] i=new int[3][5];
//		System.out.println(i.getClass().getName());
		
		
//		int[][] x=new int[3][9];
		
//		Loophole related to array creation
	
		
		
//		1.At the time of array creation compulsory we should specify the size of array otherwise we will get CTE
//		int[] x = new int[];
//		int[] x= new int[0];
//		System.out.println(x); // Variable must provide either dimension expressions or an array initializer
		
		
//		int [] x = new int[9];
//		System.out.println(x);  // [I@2c7b84de
//		System.out.println(x.getClass().getName());// [I
		
//		System.out.println(args.length);//0
//		int[] x = new int[0]; // 2.it is legal to have array with size 0 in java
		
//	    3. if we are trying to specify some negative value then it will get some RTE. say: NegativeArraySizeException
		
//		int[] x = new int[-3];
//		System.out.println(x.length);// RunTimeException--- java.lang.NegativeArraySizeException: -3
		
		
//		int[] x = new int[-9];
//		System.out.println(x);  // Exception in thread "main" java.lang.NegativeArraySizeException: -9
		
//		Because the job of compiler is to check whether we are applying the size to array or not either its +ve or -ve doesn't matter.
//		 along with that it is int value or not..along sign =ve and -ve are not checked by compiler.
//		and at runtime JVM reserved the memory for size of array when JVM see +ve and -ve size/sign then through RE.
		
//		To specify array size the allowed datat types are in java is onlt byte, short,int,char
		
//		if we trying to apply any other datat type  then we will get CTE. because maximum allowed size  in array is only 2147483647 which is int maximum value.
		
//		So that data type which can implicitly converted into int type are only allowed.
		
//		int[] x = new int[10];
//		System.out.println(x.length);// 10
//		
//		byte b=20;
//		int[] x1= new int[b];
//		System.out.println(x1.length);//20
//		
//		short s=30;
//		int[] x2 = new int[s];
//		System.out.println(x2.length);//30
		
//		int[] x9= new int['a'];//a-[I@3fee733d
//		int[] x10= new int['A'];// A- [I@3fee733d
////		System.out.println(x9); 
////		System.out.println(x9.length);//97
//		System.out.println(x10.length);//65
		
//		int[] x = new int[2147483647];
//		System.out.println(x);//  Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit
//		System.out.println(x.length);//  Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit
		
//		int[] x= new int[2147483648];
//		System.out.println(x.length);// The literal 2147483648 of type int is out of range 
		
		
//		long l=10;
//		int[] x4= new int[l];
//		int [] x = new int[2147483647]; Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit.
//		int[] x = new int[2147483648]; // The literal 2147483648 of type int is out of range 
//		System.out.println(x);  // 
		
//		Even in this first case we will get RTE if sufficient heap memory is not available in our machine/VM.
		
//		long[] l = new long[10];
//		System.out.println(l.length);//10
//		
//		long[] l1 = new long[2147483647];//Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit
//		System.out.println(l1.length);//1
		
//		char[] ch = new char[10];
//		System.out.println(ch.length);// 10
		
//		char[] ch = new char['Z'];
//		System.out.println(ch.length);// 90
		
		//Conclusion : Array ka type kuch bhi ho but array ka size sirf int tak hi le sakte hai. that sit.
		
		
//		2-D array creation-
		
//		In java 2-D array is  not implemented in matrix style some people follow array of arrays approach for multidimentional array creation.
		
//		the main advanatge of this approach is memory utilization will be improved.
		
//		int[][] x = new int[2][]; 
//		x[0] =new int[2];
//		x[1] =new int[3];
//		System.out.println(x.length);//2
//		System.out.println(x[0].length);// 2
//		System.out.println(x[1].length);// 3
//		
//		System.out.println(x);// [[I@3fee733d
		
//		int[][] x = new int['x'][]; 
//		x[0] =new int[2];
//		x[1] =new int[3];
//		
//		System.out.println(x);
//		
//		int[][][] x = new int[2][][];
//		x[0]= new int[3][];
//		x[0][0]= new int[1];
//		x[0][1] = new int[2];
//		x[0][2] = new int[3];
//		x[1] = new int[2][2];
//		
////		System.out.println(x.length);// 2
//		System.out.println(x[0][2].length);// 3
//		System.out.println(x[1].length);// 2
		
//		int[][][] x = new int[2][][];
//		x[0] = new int[3][];
//		x[0][0] = new int[1];
//		x[0][1] = new int[2];
//		x[0][2] = new int[3];
//		x[1] = new  int[2][2];
//		
//		System.out.println(x); // [[[I@2c7b84de
		
//		 Which of the  folowing array are valid.
		
//		int[] a  = new  int[];  // Variable must provide either dimension expressions or an array initializer
//		int[]  a = new int[3];  // [I@2c7b84de
//		int[][]  a = new int[][];  // Variable must provide either dimension expressions or an array initializer
//		int[][]  a = new int[3][];  // [[I@2c7b84de
//		int[][] a = new  int[][4];  // Cannot specify an array dimension after an empty dimension
//		int[][]  a = new int[3][4]; // [[I@2c7b84de
//		int[][]  a = new int[3][3];  // [[I@2c7b84de
//		int[][][]  a = new int[3][4][5];  // [[[I@2c7b84de
//		int[][][]  a = new int[3][4][];  // [[[I@2c7b84de
//		int[][][]  a = new int[3][][5];  // Cannot specify an array dimension after an empty dimension
//		int[][][]  a = new  int[][4][5];  // Cannot specify an array dimension after an empty dimension
//		System.out.println(a); 
		
//		Array Initialization.
		
//		Once  we create an array every array element initialized with default element i.e. 0.
//		int[] x = new int[3];
//		int[] x = new int[5];
//		System.out.println(x[0]);//0
//		System.out.println(x[1]);//0
//		System.out.println(x[2]);//0
//		System.out.println(x[3]);//0
//		System.out.println(x[4]);//0
//		
//		System.out.println(x.getClass().getName()); // [I
		
//		System.out.println(x[0]); // 0
		
//		whenever we are trying to print any reference variable x, 
//		internally toString() method will be called which is implemented
//		by default  to return the string with the following form.
//		classname@hashcode_in_Hexadecimalform.
		
//		System.out.println();
//		
//		int[][] x = new int[2][3];
////		
//		System.out.println(x.getClass().getName()); // [[I
//		System.out.println(x[0]); // [I@2c7b84de
//		System.out.println(x);// [[I@5acf9800
//		System.out.println(x[0][0]);  // 0
//		
//		int[][] x = new int[2][];
//		System.out.println(x);// [[I@3fee733d
//		System.out.println(x[0]);//null
//		System.out.println(x[0][0]);// Exception in thread "main" java.lang.NullPointerException:
		//Cannot load from int array because "x[0]" is null
		
//		int[][] x = new int[2][];
//		System.out.println(x);  // [[I@2c7b84de
//		System.out.println(x[0]); // null
//		System.out.println(x[0][0]); // Exception in thread "main" java.lang.NullPointerException: Cannot load from int array because "x[0]" is null
//		
		// If we are trying to perform any operation on  null then we will get NullPointerException.
		
//		index = array length-1
//		int[] x = new int[6];
//		x[0]=10;
//		x[1]=20;
//		x[2]=30;
//		x[3]=30;
//		x[4]=40;
//		x[5]=50;
		
//		int[] x = new int[6];
//		x[0]=10;
//		x[1]=20;
//		x[2]=30;
//		x[3]=40;
//		x[4]=50;
//		x[5]=60;
//		x[6]=70;
//		x[-6]=80;
//		x[2.5]=90;// Type mismatch: cannot convert from double to int
		
//		System.out.println(x[0]);
//		System.out.println(x[1]);
//		System.out.println(x[2]);
//		System.out.println(x[3]);
//		System.out.println(x[4]);
//		System.out.println(x[5]);
		
		
//		System.out.println(x[-6]);//Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index -6 out of bounds for length 6
//		System.out.println(x[6]);// Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 6 out of bounds for length 6
//		System.out.println(x[2.5]);

		
//		System.out.println(x[0]);
//		System.out.println(x[1]);
//		System.out.println(x[2]);
//		System.out.println(x[3]);
//		System.out.println(x[4]);
//		System.out.println(x[5]);
		
//		System.out.println(x[6]); // Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 6 out of bounds for length 6
		
//		 we create an array every array by default initialized with default value i.e. 0.
		
//		System.out.println(x[-6]); // "main" java.lang.ArrayIndexOutOfBoundsException: Index -6 out of bounds for length 6
		
//		System.out.println(x[2.5]); // Type mismatch: cannot convert from double to int
		
//		NOTE :- Compiler only going to check syntactical mistake at compile time.
//		like in array whether it is valid int value or not. if type of array is int. otherwise  it produce error called compile time error.
		
//		But JVM is going to check logical mistake at runtime.
//		like in array whether valid int value is in range , -ve, +ve any other mistake and when found error called runtime exception.
		
//		Array declaration,creation,initialization in a single line.
		
//		int[]  x; // array declaration
//		x = new int[3]; //array creation
//		x[0]=10; // array initialization.
//		x[1]=20;  // array initialization.
//		x[2]=30;  // array initialization.
			
//		int[] x;
//		x= new int[3];
//		
//		x[1]=20;
//		x[2]=30;
//		
//		System.out.println(x[0]);//0
//		System.out.println(x[1]);//20
//		System.out.println(x[2]);// 30
//		System.out.println(x[0]+"..."+x[1]+".."+x[2]);// 0...20..30
		

//		//		
//		int[] x = {1,2};
//		System.out.println(x[0]);// 1
//		System.out.println(x[1]);//2
//		System.out.println(x.length);//2 
//		int[] x = {10,20,30,40};
//		System.out.println(x[0]); // 10
		
		
//		char[] ch = {'a','e','i','o','u'};
//		System.out.println(ch[0]);// a
//		System.out.println(ch[1]);// e
//		System.out.println(ch[4]);// u
//		char[] x = {'a','b','c','d'};
//		System.out.println(x[0]); // a
		
//		String[] s = {"A","D","AA","","","123","1","2.3","true"};	  // S is caps because it is Non-Premitive Data type.
//		System.out.println(s[0]);
//		System.out.println(s[1]);
//		System.out.println(s[2]);
//		System.out.println(s[3]);
//		System.out.println(s[4]);
//		System.out.println(s[5]);
//		System.out.println(s[6]);
//		System.out.println(s[7]);
//		System.out.println(s[8]);
		
//		String[] s = {"A","D","AA","","","123","1","2.3","true"};
		
//		System.out.println(s[0]);
//		System.out.println(s[1]);
//		System.out.println(s[2]);
//		System.out.println(s[3]);
//		System.out.println(s[4]);
//		System.out.println(s[5]);
//		System.out.println(s[6]);
//		System.out.println(s[7]);
//		System.out.println(s[8]);
		
		
//		int[][] x= {{1},{2}};
//		System.out.println(x[0]);// [I@3fee733d
//		System.out.println(x[0][0]);// 1
//		System.out.println(x[1][0]);// 2
		
//		int[][] x= {{10,20,30},{40,50,60}};
//		System.out.println(x[0][0]); // 10
//		System.out.println(x[0][1]);
//		System.out.println(x[0][2]);
//		System.out.println(x[1][0]);
//		System.out.println(x[1][1]);
//		System.out.println(x[1][2]);// 60
		
		
		
//		int[][]  x = {{10,20,30},{40,50,60}};  2-D Array - declaaration,creation, initialaization
//		here bracket representation dimentions.
//		System.out.println(x[0]);
//		System.out.println(x[0][0]);
//		System.out.println(x[0][1]);
//		System.out.println(x[0][2]);
//		System.out.println(x[1][0]);
//		System.out.println(x[1][1]);
//		System.out.println(x[1][2]);
		
//		3-D array declaaration,creation, initialaization
		
//		int[][][] x= {{{10,20,30},{40,50,60},{70,80,90}}};
//		System.out.println(x[0]);// [[I@3fee733d
//		System.out.println(x[1]);
//		System.out.println(x[2]);
//		
//		System.out.println(x[0][0]);// [I@3fee733d
//		System.out.println(x[0][1]);// [I@5acf9800
//		System.out.println(x[0][2]);//  [I@4617c264
		
//		System.out.println(x[0][0][0]);// 10
//		System.out.println(x[0][0][1]);// 20
//		System.out.println(x[0][0][2]);// 30
//		
//		System.out.println(x[0][1][0]);// 40
//		System.out.println(x[0][1][1]);// 50
//		System.out.println(x[0][1][2]);// 60
//		
//		System.out.println(x[0][2][0]);// 70
//		System.out.println(x[0][2][1]);// 80
//		System.out.println(x[0][2][2]);// 90
		
		
		
//		int[][][]  x = {{{10,20,30},{40,50,60,70},{80,90,100,110}}};
//		System.out.println(x[0][0][0]);
//		System.out.println(x[0][0][1]);
//		System.out.println(x[0][0][2]);
//		System.out.println(x[0][1][0]);
//		System.out.println(x[0][1][1]);
//		System.out.println(x[0][1][2]);
//		System.out.println(x[0][1][3]);
//		System.out.println(x[0][2][0]);
//		System.out.println(x[0][2][1]);
//		System.out.println(x[0][2][2]);
//		System.out.println(x[0][2][3]);
		
//		System.out.println(x[0]);  // [[I@2c7b84de
//		System.out.println(x[0][0]); // [I@2c7b84de
		
		
//		int[][][]  x = {{{10,20,30},{40,50,60,70,80}},{{90,100,110,120},{130,140,150,160}}};
//		System.out.println(x[0][0][0]);
//		System.out.println(x[0][0][1]);
//		System.out.println(x[0][0][2]);
//		System.out.println(x[0][1][0]);
//		System.out.println(x[0][1][1]);
//		System.out.println(x[0][1][2]);
//		System.out.println(x[0][1][3]);
//		System.out.println(x[0][1][4]);
//		System.out.println(x[1][0][0]);
//		System.out.println(x[1][0][1]);
//		System.out.println(x[1][0][2]);
//		System.out.println(x[1][0][3]);
//		System.out.println(x[1][1][0]);
//		System.out.println(x[1][1][1]);
//		System.out.println(x[1][1][2]);
//		System.out.println(x[1][1][3]);
//		System.out.println(x[0][1][4]);
		
		
//		int[][][]  x = {{{10,20,30},{40,50,60,70,80}},{{90,100,110,120},{130,140,150,160}}};
		
		
//		System.out.println(x[0][0][0]);
//		System.out.println(x[0][0][1]);
//		System.out.println(x[0][0][2]);
//		System.out.println(x[0][1][0]);
//		System.out.println(x[0][1][1]);
//		System.out.println(x[0][1][2]);
//		System.out.println(x[0][1][3]);
//		System.out.println(x[0][1][4]);
//		System.out.println(x[1][0][0]);
//		System.out.println(x[1][0][1]);
//		System.out.println(x[1][0][2]);
//		System.out.println(x[1][0][3]);
//		System.out.println(x[1][1][0]);
//		System.out.println(x[1][1][1]);
//		System.out.println(x[1][1][2]);
//		System.out.println(x[1][1][3]);

		
		
//		System.out.println(x[0][0][8]); // Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length 3
//		System.out.println(x[0][4][0]); // Index 4 out of bounds for length 2
//		System.out.println(x[1][0][2]); // 110
//		System.out.println(x[1][5][8]); // Index 5 out of bounds for length 2
//		System.out.println(x[6][5][8]); //  Index 6 out of bounds for length 2
//		System.out.println(x[1][1][8]);
//		System.out.println(x[1][5][8]);
//		System.out.println(x[1][5][8]);
		
//	    int x; // declare
//	    x = 10; // initialize
//	    System.out.println(x); // 10
		
//		int x;
//		x=10;
//		System.out.println(x);
		
//		int[] x;
//		x = {10,20,30,40,50,60,70}; // Array constants can only be used in initializers
//		System.out.println(x[0]);
//		
//		int[] x;
//		x= {10,20,30,40,50};
//		System.out.println(x[0]);// Array constants can only be used in initializers
		
//		So, from above we can say that if we want  to use this  shortcut we can
//		perform all the activities in a single line, otherwise if perform and divide 
//		in multiple line the we will get CTE.
		
		
//		Length -- variable  Vs   Length() -- method
//		var     Vs   method
//		
//		int[] x = new int[6];
//		System.out.println(x.length()); // Cannot invoke length() on the array type int[]
//		System.out.println(x.length); // 6
		
//		int[] x = new int[6];
////		System.out.println(x.length());
//		System.out.println(x.length);
		
//		length is a final variable applicable for array.
//		length variable represent size of array.
		
//		length():-
//		String s = "durga";
//		System.out.println(s.length()); // 5
//		System.out.println(s.length); // length cannot be resolved or is not a field
		
//		length() method is final method applicable for string objects
//		length() method returns no of characters present in the String
		
//		Concept:-
//		
//		final class String
//		{
//			length()
//			{
//				
//			}
//		}
//		
//		String s = "Fahad";
//		System.out.println(s.length());// 5 - no of charcter in string
//		String s = "Apathfromapointapproximately330metreseastofthemostsouthwesterlycornerof17BathertonClose,Widnesandapproximately208metreseast-south-eastofthemostsoutherlycornerofUnit3FoundryIndustrialEstate,VictoriaStreet,Widnes,proceedinginagenerallyeast-north-easterlydirectionforapproximately28metrestoapointapproximately202metreseast-south-eastofthemostsouth-easterlycornerofUnit4FoundryIndustrialEstate,VictoriaStreet,andapproximately347metreseastofthemostsouth-easterlycornerof17BathertonClose,thenproceedinginagenerallynortherlydirectionforapproximately21metrestoapointapproximately210metreseastofthemostsouth-easterlycornerofUnit5FoundryIndustrialEstate,VictoriaStreet,andapproximately202metreseast-south-eastofthemostnorth-easterlycornerofUnit4FoundryIndustrialEstate,VictoriaStreet,thenproceedinginagenerallyeast-north-eastdirectionforapproximately64metrestoapointapproximately282metreseast-south-eastofthemosteasterlycornerofUnit2FoundryIndustrialEstate,VictoriaStreet,Widnesandapproximately259metreseastofthemostsoutherlycornerofUnit4FoundryIndustrialEstate,VictoriaStreet,thenproceedinginagenerallyeast-north-eastdirectionforapproximately350metrestoapointapproximately3metreswest-north-westofthemostnorthwesterlycorneroftheboundaryfenceofthescrapmetalyardonthesouthsideofCornubiaRoad,Widnes,andapproximately47metreswest-south-westofthestubendofCornubiaRoadbedivertedtoa3metrewidepathfromapointapproximately183metreseast-south-eastofthemosteasterlycornerofUnit5FoundryIndustrialEstate,VictoriaStreetandapproximately272metreseastofthemostnorth-easterlycornerof26AnnStreetWest,Widnes,thenproceedinginagenerallynortheasterlydirectionforapproximately58metrestoapointapproximately216metreseast-south-eastofthemosteasterlycornerofUnit4FoundryIndustrialEstate,VictoriaStreetandapproximately221metreseastofthemostsoutherlycornerofUnit5FoundryIndustrialEstate,VictoriaStreet,thenproceedinginagenerallyeasterlydirectionforapproximately45metrestoapointapproximately265metreseast-south-eastofthemostnorth-easterlycornerofUnit3FoundryIndustrialEstate,VictoriaStreetandapproximately265metreseastofthemostsoutherlycornerofUnit5FoundryIndustrialEstate,VictoriaStreet,thenproceedinginagenerallyeast-south-eastdirectionforapproximately102metrestoapointapproximately366metreseast-south-eastofthemosteasterlycornerofUnit3FoundryIndustrialEstate,VictoriaStreetandapproximately463metreseastofthemostnortheasterlycornerof22AnnStreetWest,Widnes,thenproceedinginagenerallynorth-north-easterlydirectionforapproximately19metrestoapointapproximately368metreseast-south-eastofthemosteasterlycornerofUnit3FoundryIndustrialEstate,VictoriaStreetandapproximately512metreseastofthemostsoutheasterlycornerof17BathertonClose,Widnesthenproceedinginagenerallyeast-south,easterlydirectionforapproximately16metrestoapointapproximately420metreseast-south-eastofthemostsoutherlycornerofUnit2FoundryIndustrialEstate,VictoriaStreetandapproximately533metreseastofthemostsouth-easterlycornerof17BathertonClose,thenproceedinginagenerallyeast-north-easterlydirectionforapproximately240metrestoapointapproximately606metreseastofthemostnortherlycornerofUnit4FoundryIndustrialEstate,VictoriaStreetandapproximately23metressouthofthemostsouthwesterlycorneroftheboundaryfencingofthescrapmetalyardonthesouthsideofCornubiaRoad,Widnes,thenproceedinginagenerallynortherndirectionforapproximately44metrestoapointapproximately3metreswest-north-westofthemostnorthwesterlycorneroftheboundaryfenceofthescrapmetalyardonthesouthsideofCornubiaRoadandapproximately47metreswest-south-westofthestubendofCornubiaRoad.Thesentencebelowwasfoundinalegalcontract,andwasuntilrecentlythelongestsentencewehadseeninanofficialdocument.516words'IntheeventthatthePurchaserdefaultsinthepaymentofanyinstalmentofpurchaseprice,taxes,insurance,interest,ortheannualchargedescribedelsewhereherein,orshalldefaultintheperformanceofanyotherobligationssetforthinthisContract,theSellermay:athisoption:(a)Declareimmediatelydueandpayabletheentireunpaidbalanceofpurchaseprice,withaccruedinterest,taxes,andannualcharge,anddemandfullpaymentthereof,andenforceconveyanceofthelandbyterminationofthecontractoraccordingtothetermshereof,inwhichcasethePurchasershallalsobeliabletotheSellerforreasonableattorney'sfeesforservicesrenderedbyanyattorneyonbehalfoftheSeller,or(b)sellsaidlandandpremisesoranypartthereofatpublicauction,insuchmanner,atsuchtimeandplace,uponsuchtermsandconditions,anduponsuchpublicnoticeastheSellermaydeembestfortheinterestofallconcerned,consistingofadvertisementinanewspaperofgeneralcirculationinthecountyorcityinwhichthesecuritypropertyislocatedatleastonceaweekforThree(3)successiveweeksorforsuchperiodasapplicablelawmayrequireand,incaseofdefaultofanypurchaser,tore-sellwithsuchpostponementofsaleorresaleanduponsuchpublicnoticethereofastheSellermaydetermine,anduponcompliancebythePurchaserwiththetermsofsale,anduponjudicialapprovalasmayberequiredbylaw,conveysaidlandandpremisesinfeesimpletoandatthecostofthePurchaser,whoshallnotbeliabletoseetotheapplicationofthepurchasemoney;andfromtheproceedsofthesale:Firsttopayallpropercostsandcharges,includingbutnotlimitedtocourtcosts,advertisingexpenses,auctioneer'sallowance,theexpenses,ifanyrequiredtocorrectanyirregularityinthetitle,premiumforSeller'sbond,auditor'sfee,attorney'sfee,andallotherexpensesofsaleoccurredinandabouttheprotectionandexecutionofthiscontract,andallmoneysadvancedfortaxes,assessments,insurance,andwithinterestthereonasprovidedherein,andalltaxesdueuponsaidlandandpremisesattimeofsale,andtoretainascompensationacommissionoffivepercent(5%)ontheamountofsaidsaleorsales;SECOND,topaythewholeamountthenremainingunpaidoftheprincipalofsaidcontract,andinterestthereontodateofpayment,whetherthesameshallbedueornot,itbeingunderstoodandagreedthatuponsuchsalebeforematurityofthecontractthebalancethereofshallbeimmediatelydueandpayable;THIRD,topayliensofrecordagainstthesecuritypropertyaccordingtotheirpriorityoflienandtotheextentthatfundsremaininginthehandsoftheSellerareavailable;andLAST,topaytheremainderofsaidproceeds,ifany,tothevendor,hisheirs,personalsrepresentatives,successorsorassignsuponthedeliveryandsurrendertothevendeeofpossessionofthelandandpremises,lesscostsandexcessofobtainingpossession.";
//		System.out.println(s.length()); // 45
//		System.out.println(s.length);// length cannot be resolved or is not a field
		
//		Inprogress -- 1547 line
		
//		Now, length() method present in string class and string class is final. 
//		so its not possible to create child and also cant override this method.
//		because we can overrride only in child class.  thats why this method
//		is by default always final.
		
//		Conclusion:-
//		Every method present in final class is always final.
		
//		lenght variable applicable for array but not for string Objects.
//		class whereas length() method applicable for String objects but not for array
		
//		String[] s = {"A","AA","AAA"};
//		System.out.println(s.length); //3
		
//		System.out.println(s.length);// 3
//		System.out.println(s.length()); // Cannot invoke length() on the array type String[]
//		System.out.println(s[0].length);// length cannot be resolved or is not a field for string object
//		System.out.println(s[0].length()); // 1
		
//		System.out.println(s.length()); // Cannot invoke length() on the array type String[]
//		System.out.println(s[0].length); // length cannot be resolved or is not a field
//		System.out.println(s[0].length()); // 1
		
//		System.out.println(s.length);// 3
		
//		System.out.println(s[0]);
//		System.out.println(s[1]);
//		System.out.println(s[2]);
		
//		System.out.println(s[0].length());
//		System.out.println(s[1].length());
//		System.out.println(s[2].length());
		
//		int[][] x = new int[6][3];
////		System.out.println(x.length); // 6
		
		
//		In Multidimentional arrays -- length var. represent only base size but not total size of array
//		System.out.println(x[0].length); // 3
//		?There is no direct way to find total length of multidimentional Array.class but indirectly we can find 
//		
//		System.out.println(x.length+x[0].length+x[1].length+x[2].length+x[3].length+x[4].length+x[5].length);  // 24
		
//		int[][] x = new int[6][3];
//		System.out.println(x.length);// gives us base length only i.e. 6
		
//		System.out.println(x.length +x[0].length+x[1].length+x[2].length+x[3].length+x[4].length+x[5].length);// 24
		
//		int[][][] x = new int [10][2][3];
		
//		System.out.println(x.length+x[0].length+x[0][0].length+x[0][1].length+x[1].length+x[1][0].length+x[1][1].length);
		
//		System.out.println(x.length+x[0].length+x[0][0].length+x[0][1].length+x[1].length+x[1][0].length+x[1][1].length);
//		System.out.println(x.length); //.length+x[0][0].length+x[0][1].length+x[1].length+x[1][0].length+x[1][1].length);
//		System.out.println(x[0].length); 
//		System.out.println(x[0][0].length); 
//		System.out.println(x[0][1].length); 
		
//		System.out.println(x.length+(x.length*x[0].length) + (x.length*x[0].length)*(x[0][0].length));// 90
		
//		   int lengthDimension1 = x.length;         // Length of the first dimension (10)
//	        int lengthDimension2 = x[0].length;      // Length of the second dimension (2)
//	        int lengthDimension3 = x[0][0].length;   // Length of the third dimension (3)
//	        int lastIndexDimension1 = lengthDimension1 - 1;
//	        int lastIndexDimension2 = lengthDimension2 - 1;
//	        int lastIndexDimension3 = lengthDimension3 - 1;
//
//	        System.out.println("Length of Dimension 1: " + lengthDimension1);
//	        System.out.println("Last Index of Dimension 1: " + lastIndexDimension1);
//	        System.out.println("Length of Dimension 2: " + lengthDimension2);
//	        System.out.println("Last Index of Dimension 2: " + lastIndexDimension2);
//	        System.out.println("Length of Dimension 3: " + lengthDimension3);
//	        System.out.println("Last Index of Dimension 3: " + lastIndexDimension3);
//		
//		  int totalLength = x.length * x[0].length * x[0][0].length;
	        
//	        System.out.println("Total Length of the 3-D Array: " + totalLength); // 60
		
		
//		Anonymous array :-
//		Sometime we can declare array without name such type of  nameless array called anonymous array
//		The main purpose of anonymous array  is for instant use(one time use).
		 
//		sum(new int[] {10,20,30,40});	
//		sum(new int[] {10,20,30});
		
//		new   int[]{10,20,30,40}; // anonymous array
		
//		While we creating anonymous array we cant specify the size.
		
//	    new int[] {10,20,30,40};// true
//		new int[4] {10,20,30,40};  // false
		
//		int[] x = {10,20,30};
//		int[] x1= new int[] {10,30,40};
//		
//		System.out.println(x[0]);
//		System.out.println(x[1]);
//		System.out.println(x[2]);
//		
//		System.out.println(x1[0]);
//		System.out.println(x1[1]);
//		System.out.println(x1[2]);
		
		
		
		
//		we can create multidimentional anonymous array also.
//		 new int[][] {{10,20,30},{40,50,60}}; // 2-D array
//		Based on our requirement we can give the name of array so it will no longer anonymous array.
//		
//		new int[][] {{10,20},{30,40}}};
//		int[] [] x = new int[][] {{10,20},{30,40}}; // no longer anonymous array
//		 ex :-
		
//		int[] x = {10,20,30,40,50}; // x[0] == 10
//		int[] x = new int[] {10,20,30,40,50}; // x[0]  == 10
//		System.out.println(x[0]);
		
//		int[] x = new int[5];
//		System.out.println(x[0]); // 0
//		System.out.println(x[1]);  // 0
//		System.out.println(x[4]);  // 0
		
//		 In the above example just to call sum method we requires an array but after completing sum method call we are not using that array
//		anymore, hence for this one time requirement anonymous array is the best coice.
		
		
//		Array Element Assigment:-
		
//		Case1:-
//				In the case of primitive types array as array element we can
//		provide any type which can be implicitly promoted to declared type.
		 
//		int[] x = new int[5];
//		x[0]=10;
//		x[1]='a';
//		byte b = 20;
//		x[2]=b;
//		short s = 30;
//		x[3]=s;
////		x[4]=10l;  // Type mismatch: cannot convert from long to int
//		
//		System.out.println(x[0]); // 10
//		System.out.println(x[1]); // 97
//		System.out.println(x[2]); // 20
//		System.out.println(x[3]); // 30
//		System.out.println(x[4]);  // Type mismatch: cannot convert from long to int
		
//		int[] x= new int[6];
//		
//		x[0]= 10;
//		byte b = 20;
//		x[1] = b;
//		short s1 = 30;
//		x[2] = s1;
//		char ch = 'A';
//		x[3] = ch;
//		int i = 20;
//		x[4] = i;
//		
//		System.out.println(x[0]+".."+x[1]+".."+x[2]+".."+x[3]+".."+x[4]+".."+x[5]);
		
		
//		double [] d = new double[7];
//		d[0] = 10;
//		byte b = 20;
//		d[1] = b;
//		short s1= 30;
//		d[2] = s1;
//		long l = 209l;
//		d[3] = l;
//		char ch = 'A';
//		d[4] = ch;
//		float f= 10.3f;
//		d[5] = f;
//		d[6] = 10.908;
//		
//		System.out.println(d[0]+".."+d[1]+".."+d[2]+".."+d[3]+".."+d[4]+".."+d[5]+".."+d[6]);
		// 10.0..20.0..30.0..209.0..65.0..10.300000190734863..10.908
		
		
//		
//		In the case of float type array the allowed dataType are byte,short, int, char,long,float.
		
//		float[] f = new float[6];
//		f[0]=10;
//		byte b = 20;
//		f[1]=b;
//		short s = 30;
//		f[2]=s;
//		long l = 40l;
//		f[3]=l;
//		f[4]='A';
//		f[5]= 1.3f;
//		System.out.println(f[0]);
//		System.out.println(f[1]);
//		System.out.println(f[2]);
//		System.out.println(f[3]);
//		System.out.println(f[4]);
//		System.out.println(f[5]);
		
//		Case 2:-
//				In the case of object type arrays as array element
//		we can provide either declared type object or its child class objects
		
//		 Object[]  a = new Object[10];  // object is parent 
		
//		 a[0]= new Object();           // declared type object is child.
//		 a[1]= new String("durga");   // String is child of object class
//		 a[2]= new Integer(10);      // Integer is child of object clas
//		 
//		 System.out.println(a[0]);  // java.lang.Object@2c7b84de
//		 System.out.println(a[1]);  // durga
//		 System.out.println(a[2]);  // 10
		 
//		 Object[] a = new Object[10];
//		 
//		 a[0] = new Object();
//		 a[1] = new String("Fahad");
//		 a[2] = new Integer(10);
//		 
//		 System.out.println(a[0]);// java.lang.Object@3fee733d
//		 System.out.println(a[1]); // Fahad
//		 System.out.println(a[2]);// 10
		 
		
		
//		Number[] n = new Number[10];
//		n[0]=new Integer(10);  // 10
//		n[1]=new Double(10.5);  // 10.5
//		n[2]=new String("durga");   // Type mismatch: cannot convert from String to Number
//		 System.out.println(n[0]);
//		 System.out.println(n[1]);
//		 System.out.println(n[2]); //  Type mismatch: cannot convert from String to Number
		
		
//		Number[] n = new Number[10];
//		n[0] = new Integer(10);
//		n[1] = new Double(10.5);
//		n[2] = new String("Fahad");
//		
//		System.out.println(n[0]);
//		System.out.println(n[1]);
//		System.out.println(n[0]);
		
		
//		Case 3:-
//				for interface type arrays as array element its implimentation class objects are allowed.
		
//		Runnable[] r = new Runnable[10];
		
//		r[0]= new Thread();
//  	r[1]= new String("Durga");
//		System.out.println(r[0]);  // Thread[Thread-0,5,main]
//		System.out.println(r[1]); // Type mismatch: cannot convert from String to Runnable
		
		
//		Array Variable assingment:-
		
//		Case1:-
//				Element level promotion are  applicable at array level.
		
////		ex :- char element can be promoted to int Type. whereas char[] can not be prormoted ot int[] array.
//		int[] x = {10,20,30,40,50};
//		char[] ch = {'A','B','C','D'};
		
//		int[] b = x;
//		System.out.println(b[0]);
//		System.out.println(b[1]);
//		System.out.println(b[2]);
//		System.out.println(b[3]);
//		
//		System.out.println(ch[0]); // A
//////		int[] c = ch;
//		int[] x= {10,20,30,40};
//		char[] ch = {'A','B','C','D'};
//		
//		int[] c = ch;
//		System.out.println(c[0]);// Type mismatch: cannot convert from char[] to int[]
//		System.out.println(c[0]); // Type mismatch: cannot convert from char[] to int[]
		
//		String[] s = {"A","BB","CCC"};
//		Object[] a = s;
//		
//		
//		String[] s1 = {"A","B","C","D"};
//		Object[] obj = s1;
//		
//		System.out.println(obj[0]);
//		System.out.println(obj[1]);
//		System.out.println(obj[2]);
//		
//		System.out.println(a[0]); // A
//		System.out.println(a[1]);  // BB
//		System.out.println(a[2]);// CCC
		
//		Here Object is parent and String is child--- So int his case  of object type arrays 
//		child class type array can be promoted to parent type array.
		
//		char--> int == true
//		char[]--> int[] == flase
//		int--> double  == true
//		int[]--> double[] == false
//		float--> int  == false
//		float[]--> int[] == false
//		String--> Object == true
//		String[]--> Object[] == true  need to cross check with help of example
		
//		String[] s2 = {"Fa","SD","DD","FF"};
//		Object[] obj = s2;
//		System.out.println(obj[2]);
		
		
//		
////		int[] x = {10,20,'A','B'};
////		System.out.println(x[2]); //  char--> int == true
		
//		int[] x = {10,20,30,'A','B','C'};
//		System.out.println(x[0]);// 10
//		System.out.println(x[3]);// 65
		
		
//		
////		char[] ch = {'A','B','C'};
////		int[] x = ch; // char[]--> int[] == flase
////		System.out.println(x[0]); // 	Type mismatch: cannot convert from char[] to int[]
		
//		double[] d= {10,20,30,40};
//		System.out.println(d[0]); // 10.0
//		System.out.println(d[1]); // 20.0
//		System.out.println(d[2]);
//		System.out.println(d[3]);
		
//		int[] x = {10,20,30,40};
//		double[] d = x;
//		System.out.println(d[0]); // Type mismatch: cannot convert from int[] to double[]
		
//		Case 2 :-
		
//		whenever we are assigning one array to another array internal element won't be copied. just reeference variable will be reassigned
//		but both the variable have same type.
		
//		int[] x= {10,20,30,40,50,60,70};
//		int[] y = {20,30,40,50};
//   	x=y;
//		y=x;
		
//		System.out.println(x[0]);
//		System.out.println(x[1]);
//		System.out.println(x[2]);
//		System.out.println(x[3]);
//		System.out.println(x[4]);// Index 4 out of bounds for length 4
		
//		System.out.println(y[0]);
//		System.out.println(y[1]);
//		System.out.println(y[2]);
//		System.out.println(y[3]);
//		System.out.println(y[4]);
//		System.out.println(y[5]);
		
		
		
//		int[] x = {10,20,30,40,50,60,70};
//		int[] y = {90,100,110,120,130,140,150};
//		x=y;
//		y=x;
//		System.out.println(y[0]); // 90
//		System.out.println(y[1]); // 100
//		System.out.println(y[2]);  // ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2
//		System.out.println(y[3]);
//		System.out.println(y[4]);
//		System.out.println(y[5]);
//		System.out.println(y[6]);
//		
//		System.out.println(x[0]);
//		System.out.println(x[1]);
//		System.out.println(x[2]);
//		System.out.println(x[3]);
//		System.out.println(x[4]);
//		System.out.println(x[5]);
//		System.out.println(x[6]);
//	
//		Form above we can compare whenever we are trying to assign one array to another array
//	    dimension  must be matched, but size are not required to matched.	
		
//		int x[]= {10,20,30,40};
//		int[] y= {50,60,70};
//		
//
//		y=x;
//		System.out.println(x[0]); // 50
//		System.out.println(x[1]); // 60
//		System.out.println(x[2]); // 70

//		
//		System.out.println(y[0]);  // 10
//		System.out.println(y[1]); // 20
//		System.out.println(y[2]);  // 30
//		System.out.println(y[3]);  // 40
		
//		int x[] = {10,20,30,40};
//		int y[] = {50,60,70,80,90,100};
//		
//		x=y;
////		y=x;
//		System.out.println(y[0]);
//		System.out.println(y[1]);
//		System.out.println(y[2]);
//		System.out.println(y[3]);
//		
//		System.out.println(x[0]);
//		System.out.println(x[1]);
//		System.out.println(x[2]);
//		System.out.println(x[3]);
//		System.out.println(x[4]);
//		System.out.println(x[5]);
	
		
//		Case 3:-
//				Whenevr we assign one array to another array dimension must be matched.
		
//		ex:-
//			int[][] x = new int[3][];
//			
//			x[0] = new int[3][4];
//			System.out.println(x[0]); // Type mismatch: cannot convert from int[][] to int[]
//			
//		int[][] x = new int[3][];
//		
////		x[0] = new int[3][];
////		x[0] = 10;// Type mismatch: cannot convert from int to int[]
//		x[0] = new int[10];
//		System.out.println(x[0]);
		
		
//			x[0]= 10;  // Chahiye int[] array but insert kar rahe int value
//			System.out.println(x[0]);  // Type mismatch: cannot convert from int to int[]
			
//			x[0]= new int[2];
//			System.out.println(x[0]); // [I@2c7b84de
		
//		 int [] x = {12,23,34};
//		 for(int i=0; i<= x.length;i++)
//		 {
//			 System.out.println(x[i]);
//		 }
		
		 
//		String[] argh = {"x","y","z"};
//		args=argh;
//		for(String s: args) {
//			System.out.println(s);
//		}
		
//		String[] argh = {"x","y","z"};
//		args =argh;
//		for(String s1 : args) {
//			System.out.println(s1);// x, y, z
//		}
//		
//		int[][] a = new int[4][3];
//		a[0]=new int[4];
//		a[1]= new int[2];
//		a=new  int[3][2];
		
//		System.out.println(a[4][3]); // Index 4 out of bounds for length 3
//		System.out.println(a[0][2]); // : Index 2 out of bounds for length 2  
//		Object created == 11
//		Eligible for GC == 7
		
//		*************--END OF ARRAY CONCEPT BY DURGA SIR-************ (596-1279= 683 line me concept)
//        array end
		
	 
//		 String input = "A path from a point approximately 330 metres east of the most south westerly corner of 17 Batherton Close, Widnes and approximately 208 metres east-south-east of the most southerly corner of Unit 3 Foundry Industrial Estate, Victoria Street, Widnes, proceeding in a generally east-north-easterly direction for approximately 28 metres to a point approximately 202 metres east-south-east of the most south-easterly corner of Unit 4 Foundry Industrial Estate, Victoria Street, and approximately 347 metres east of the most south-easterly corner of 17 Batherton Close, then proceeding in a generally northerly direction for approximately 21 metres to a point approximately 210 metres east of the most south-easterly corner of Unit 5 Foundry Industrial Estate, Victoria Street, and approximately 202 metres east-south-east of the most north-easterly corner of Unit 4 Foundry Industrial Estate, Victoria Street, then proceeding in a generally east-north-east direction for approximately 64 metres to a point approximately 282 metres east-south-east of the most easterly corner of Unit 2 Foundry Industrial Estate, Victoria Street, Widnes and approximately 259 metres east of the most southerly corner of Unit 4 Foundry Industrial Estate, Victoria Street, then proceeding in a generally east-north-east direction for approximately 350 metres to a point approximately 3 metres west-north-west of the most north westerly corner of the boundary fence of the scrap metal yard on the south side of Cornubia Road, Widnes, and approximately 47 metres west-south-west of the stub end of Cornubia Road be diverted to a 3 metre wide path from a point approximately 183 metres east-south-east of the most easterly corner of Unit 5 Foundry Industrial Estate, Victoria Street and approximately 272 metres east of the most north-easterly corner of 26 Ann Street West, Widnes, then proceeding in a generally north easterly direction for approximately 58 metres to a point approximately 216 metres east-south-east of the most easterly corner of Unit 4 Foundry Industrial Estate, Victoria Street and approximately 221 metres east of the most southerly corner of Unit 5 Foundry Industrial Estate, Victoria Street, then proceeding in a generally easterly direction for approximately 45 metres to a point approximately 265 metres east-south-east of the most north-easterly corner of Unit 3 Foundry Industrial Estate, Victoria Street and approximately 265 metres east of the most southerly corner of Unit 5 Foundry Industrial Estate, Victoria Street, then proceeding in a generally east-south-east direction for approximately 102 metres to a point approximately 366 metres east-south-east of the most easterly corner of Unit 3 Foundry Industrial Estate, Victoria Street and approximately 463 metres east of the most north easterly corner of 22 Ann Street West, Widnes, then proceeding in a generally north-north-easterly direction for approximately 19 metres to a point approximately 368 metres east-south-east of the most easterly corner of Unit 3 Foundry Industrial Estate, Victoria Street and approximately 512 metres east of the most south easterly corner of 17 Batherton Close, Widnes then proceeding in a generally east-south, easterly direction for approximately 16 metres to a point approximately 420 metres east-south-east of the most southerly corner of Unit 2 Foundry Industrial Estate, Victoria Street and approximately 533 metres east of the most south-easterly corner of 17 Batherton Close, then proceeding in a generally east-north-easterly direction for approximately 240 metres to a point approximately 606 metres east of the most northerly corner of Unit 4 Foundry Industrial Estate, Victoria Street and approximately 23 metres south of the most south westerly corner of the boundary fencing of the scrap metal yard on the south side of Cornubia Road, Widnes, then proceeding in a generally northern direction for approximately 44 metres to a point approximately 3 metres west-north-west of the most north westerly corner of the boundary fence of the scrap metal yard on the south side of Cornubia Road and approximately 47 metres west-south-west of the stub end of Cornubia Road.\r\n"
//		 		+ "\r\n"
//		 		+ "The sentence below was found in a legal contract, and was until recently the longest sentence we had seen in an official document.\r\n"
//		 		+ "\r\n"
//		 		+ "516 words\r\n"
//		 		+ "'In the event that the Purchaser defaults in the payment of any instalment of purchase price, taxes, insurance, interest, or the annual charge described elsewhere herein, or shall default in the performance of any other obligations set forth in this Contract, the Seller may: at his option: (a) Declare immediately due and payable the entire unpaid balance of purchase price, with accrued interest, taxes, and annual charge, and demand full payment thereof, and enforce conveyance of the land by termination of the contract or according to the terms hereof, in which case the Purchaser shall also be liable to the Seller for reasonable attorney's fees for services rendered by any attorney on behalf of the Seller, or (b) sell said land and premises or any part thereof at public auction, in such manner, at such time and place, upon such terms and conditions, and upon such public notice as the Seller may deem best for the interest of all concerned, consisting of advertisement in a newspaper of general circulation in the county or city in which the security property is located at least once a week for Three (3) successive weeks or for such period as applicable law may require and, in case of default of any purchaser, to re-sell with such postponement of sale or resale and upon such public notice thereof as the Seller may determine, and upon compliance by the Purchaser with the terms of sale, and upon judicial approval as may be required by law, convey said land and premises in fee simple to and at the cost of the Purchaser, who shall not be liable to see to the application of the purchase money; and from the proceeds of the sale: First to pay all proper costs and charges, including but not limited to court costs, advertising expenses, auctioneer's allowance, the expenses, if any required to correct any irregularity in the title, premium for Seller's bond, auditor's fee, attorney's fee, and all other expenses of sale occurred in and about the protection and execution of this contract, and all moneys advanced for taxes, assessments, insurance, and with interest thereon as provided herein, and all taxes due upon said land and premises at time of sale, and to retain as compensation a commission of five percent (5%) on the amount of said sale or sales; SECOND, to pay the whole amount then remaining unpaid of the principal of said contract, and interest thereon to date of payment, whether the same shall be due or not, it being understood and agreed that upon such sale before maturity of the contract the balance thereof shall be immediately due and payable; THIRD, to pay liens of record against the security property according to their priority of lien and to the extent that funds remaining in the hands of the Seller are available; and LAST, to pay the remainder of said proceeds, if any, to the vendor, his heirs, personals representatives, successors or assigns upon the delivery and surrender to the vendee of possession of the land and premises, less costs and excess of obtaining possession.";
//	        String stringWithoutSpaces = removeSpaces(input);
//	        System.out.println("Original String: " + input);
//	        System.out.println("String without Spaces: " + stringWithoutSpaces);
		
		
		
		} // -- main method end


	
//	    public static String removeSpaces(String input) {
//	        // Use regular expression to replace all spaces with an empty string
//	        return input.replaceAll("\\s+", "");
//	    }
//	
//
//	public static  void sum(int x) 
//	{
//		int total =0;
//		for(int x1 :x) {
//			total = total + x1;
//		}
//		System.out.println("The sum is : " + total); // The method sum(int) in the type Java_Fundamentals is not applicable for the arguments (int[])
//	}
	
	
//	sum(new int[] {10,20,30});
	
//	public static void sum(int[] x) {
//		int total =0;
//		for(int x1 : x) {
//			total = total + x1;
//		}
//		System.out.println("The sum of array element is :"+ total);
//	}

}
